# Apache ECharts 5.2.0 介绍

## 全局过渡动画 Universal Transition

在 Apache ECharts 中我们一直把自然流畅的过渡动画作为我们的一个重要特性，我们希望能够通过动画去关联数据的变化，让数据的变化不会突兀的反应在图形上。

在之前的版本中，过渡动画主要应用在了相同类型的图形的位置、尺寸、形状上，而且只能作用在相同类型的系列上。比如，下面例子就是通过饼图中扇区形状的变化反映了数据分布的变化：

```js live {layout: 'lr'}
function makeRandomData() {
  return [
    {
      value: Math.random(),
      name: 'A'
    },
    {
      value: Math.random(),
      name: 'B'
    },
    {
      value: Math.random(),
      name: 'C'
    }
  ];
}
option = {
  series: [
    {
      type: 'pie',
      radius: [0, '50%'],
      data: makeRandomData()
    }
  ]
};

setInterval(() => {
  myChart.setOption({
    series: {
      data: makeRandomData()
    }
  });
}, 2000);
```

### 跨系列的形变动画

这次从 5.2.0 开始，我们引入了更强大的全局过渡动画 Universal Transition，让过渡动画不再局限于相同类型的系列之间。

在设置`universalTransition: true`开启全局过渡动画后，从饼图切换成柱状图，或者从柱状图切换成散点图，甚至旭日图和矩形树图这类复杂的图表之间，都可以通过形变的方式自然的进行动画过渡。

如下，饼图和柱状图之间的切换：

```js live {layout: 'bt'}
const dataset = {
  dimensions: ['name', 'score'],
  source: [
    ['Hannah Krause', 314],
    ['Zhao Qian', 351],
    ['Jasmin Krause ', 287],
    ['Li Lei', 219],
    ['Karle Neumann', 253],
    ['Mia Neumann', 165],
    ['Böhm Fuchs', 318],
    ['Han Meimei', 366]
  ]
};
const pieOption = {
  dataset: [dataset],
  series: [
    {
      type: 'pie',
      // 通过 id 关联需要过渡动画的系列
      id: 'Score',
      radius: [0, '50%'],
      universalTransition: true,
      animationDurationUpdate: 1000
    }
  ]
};
const barOption = {
  dataset: [dataset],
  xAxis: {
    type: 'category'
  },
  yAxis: {},
  series: [
    {
      type: 'bar',
      // 通过 id 关联需要过渡动画的系列
      id: 'Score',
      // 每个数据都是用不同的颜色
      colorBy: 'data',
      encode: { x: 'name', y: 'score' },
      universalTransition: true,
      animationDurationUpdate: 1000
    }
  ]
};

option = barOption;

setInterval(() => {
  option = option === pieOption ? barOption : pieOption;
  // 使用 notMerge 的形式可以移除坐标轴
  myChart.setOption(option, true);
}, 2000);
```

更多的常见基础图表之间的过渡：

![](images/5-2-0/universal-transition.gif)

这样的动画过渡不再仅仅局限于基础的折、柱、饼中，在柱状图和地图之间:

![](images/5-2-0/universal-transition-2.gif)

或者旭日图和矩形树图之间，甚至非常灵活的自定义系列之间都可以进行动画的过渡。

![](images/5-2-0/universal-transition-3.gif)

> 注意需要配置系列的 id 来保证需要动画过渡的系列之间能够一一对应

### 数据的分裂和合并动画

除了常见的数据更新，有时候我们还会碰到数据的聚合，下钻等交互后的更新，这个时候我们就不能直接应用一对一的动画过渡，而需要使用更多像分裂，合并这样的动画效果，来能够正确的通过图形的动画变换表达出数据的变换。

为了能够表达数据之间多对多的联系，在 5.2.0 中我们新引入了一个数据组`groupId`的概念，我们可以通过 [series.dataGroupId](${optionPath}series-bar.dataGroupId) 设置整个系列所属的组，或者更细粒度的通过 [series.data.groupId](${optionPath}series-bar.dataGroupId) 设置每个数据所属的组。如果你使用了`dataset`管理数据则更方便了，可以使用`encode.itemGroupId`来指定一个维度编码成`groupId`。

比如我们要实现一个柱状图下钻的动画，可以将下钻后的整个系列的数据都设置同一个`groupId`，然后跟下钻前的数据对应起来：

```js live {layout: 'lr'}
option = {
  xAxis: {
    data: ['Animals', 'Fruits', 'Cars']
  },
  yAxis: {},
  dataGroupId: '',
  animationDurationUpdate: 500,
  series: {
    type: 'bar',
    id: 'sales',
    data: [
      {
        value: 5,
        groupId: 'animals'
      },
      {
        value: 2,
        groupId: 'fruits'
      },
      {
        value: 4,
        groupId: 'cars'
      }
    ],
    universalTransition: {
      enabled: true,
      divideShape: 'clone'
    }
  }
};

const drilldownData = [
  {
    dataGroupId: 'animals',
    data: [
      ['Cats', 4],
      ['Dogs', 2],
      ['Cows', 1],
      ['Sheep', 2],
      ['Pigs', 1]
    ]
  },
  {
    dataGroupId: 'fruits',
    data: [
      ['Apples', 4],
      ['Oranges', 2]
    ]
  },
  {
    dataGroupId: 'cars',
    data: [
      ['Toyota', 4],
      ['Opel', 2],
      ['Volkswagen', 2]
    ]
  }
];

myChart.on('click', event => {
  if (event.data) {
    const subData = drilldownData.find(data => {
      return data.dataGroupId === event.data.groupId;
    });
    if (!subData) {
      return;
    }
    myChart.setOption({
      xAxis: {
        data: subData.data.map(item => {
          return item[0];
        })
      },
      series: {
        type: 'bar',
        id: 'sales',
        dataGroupId: subData.dataGroupId,
        data: subData.data.map(item => {
          return item[1];
        }),
        universalTransition: {
          enabled: true,
          divideShape: 'clone'
        }
      },
      graphic: [
        {
          type: 'text',
          left: 50,
          top: 20,
          style: {
            text: 'Back',
            fontSize: 18
          },
          onclick: function() {
            myChart.setOption(option, true);
          }
        }
      ]
    });
  }
});
```

通过`groupId`，我们还可以实现更丰富的聚合，下钻动画。

数据的聚合：

![](images/5-2-0/group-transition.gif)

单系列下钻成两个系列：

![](images/5-2-0/group-transition-2.gif)

## 不同粒度的调色盘取色

在上面全局过渡动画的示例中大家可能有注意到我们使用了一个之前版本没有的`colorBy`配置项，这个配置项也是我们这个版本新增加的一个特性，用来给系列配置不同粒度的调色盘取色。这个配置目前支持两种策略：

- `'series'` 按照系列取色，同一系列中的所有数据都是用相同的颜色。
- `'data'` 按照数据项取色，每个数据项都使用不同的颜色。

在之前我们是按照系列的类型固定了这个策略，比如柱状图就是固定`'series'`的策略，而饼图则是固定`'data'`的策略。

而现在新增这个配置项后，我们可以在柱状图中给每个数据项都分配不同的颜色：

```js live {layout: 'lr'}
option = {
  xAxis: {
    type: 'category',
    data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
  },
  yAxis: {
    type: 'value'
  },
  series: [
    {
      data: [120, 200, 150, 80, 70, 110, 130],
      type: 'bar',
      colorBy: 'data'
    }
  ]
};
```

或者在饼图中统一使用一个颜色：

```js live {layout: 'lr'}
option = {
  series: {
    type: 'pie',
    colorBy: 'series',
    radius: [0, '50%'],
    itemStyle: {
      borderColor: '#fff',
      borderWidth: 1
    },
    data: [
      {
        value: 335,
        name: 'Direct Visit'
      },
      {
        value: 234,
        name: 'Union Ad'
      },
      {
        value: 1548,
        name: 'Search Engine'
      }
    ]
  }
};
```

从而避免了减少我们去找调色盘颜色然去一一设置的麻烦。后续我们会对这个配置项做进一步的增强，提供更多粒度的调色盘取色的配置。

## 极坐标柱状图的标签显示

这个版本中我们给极坐标上的柱状图添加了标签的显示，并且支持丰富的标签定位配置。下面是一个最常见的标签显示在端点的进度图：

```js live {layout: 'lr'}
option = {
  angleAxis: {
    show: false,
    max: 10
  },
  radiusAxis: {
    show: false,
    type: 'category',
    data: ['AAA', 'BBB', 'CCC', 'DDD']
  },
  polar: {},
  series: [
    {
      type: 'bar',
      data: [3, 4, 5, 6],
      colorBy: 'data',
      roundCap: true,
      label: {
        show: true,
        // 试试改成 'insideStart'
        position: 'start',
        formatter: '{b}'
      },
      coordinateSystem: 'polar'
    }
  ]
};
```

更多标签位置的配置：

![](images/5-2-0/polar-bar-label.jpg)

## 空数据饼图样式

在之前，如果饼图没有数据，画面中可能就是完全空白的，因为没有任何的反馈，所以用户会疑惑是不是出 bug 了导致图中没有内容。

为了解决这个问题，这个版本我们会默认在无可显示数据的时候显示一个灰色的占位圆以防止画面中完全空白。我们可以通过`emptyCircleStyle`配置这个占位圆的样式。

```js live {layout: 'lr'}
option = {
  series: [
    {
      type: 'pie',
      data: [],
      // showEmptyCircle: false,
      emptyCircleStyle: {
        // 将样式改为空心圆
        color: 'transparent',
        borderColor: '#ddd',
        borderWidth: 1
      }
    }
  ]
};
```

如果不想要显示这个灰色的圆，也可以设置`showEmptyCircle: false`关闭。

## 高维数据的性能增强

我们从 4.0 开始引入了 [dataset](${optionPath}dataset) 用来管理图表的数据，通常情况下`dataset`提供了更方便的数据管理方式而且跟传统的方式不会有什么性能上的差别。但是在一些极端的特别高维（>100）数据的场景下，我们还是会碰到一些性能急剧下降的问题，比如下面这种通过一千个系列去可视化千维数据的场景（来自 [#11907](https://github.com/apache/echarts/issues/11907)），甚至可能导致假死。

```js
const indices = Array.from(Array(1000), (_, i) => {
  return `index${i}`;
});
const option = {
  xAxis: { type: 'category' },
  yAxis: {},
  dataset: {
    // dimension: ['date', ...indices],
    source: Array.from(Array(10), (_, i) => {
      return {
        date: i,
        ...indices.reduce((item, next) => {
          item[next] = Math.random() * 100;
          return item;
        }, {})
      };
    })
  },
  series: indices.map(index => {
    return { type: 'line', name: index };
  })
};
```

产生这个性能问题的原因是因为我们在底层会在每个系列都按照系列的需要处理一遍这个超高维度的 dataset 并且保存一份处理过后的数据以及数据的维度等元信息。这意味着刚才那个例子中需要处理并保存`1000 x 1000`个维度的信息，带来了巨大的内存和 GC 的压力，从而导致了高维度的性能的急剧下降。

在新版本中我们对这个问题做了优化，所有系列都尽可能共享 dataset 的数据（能否共享取决于系列怎么使用这份数据）存储而非每个系列都处理并存储一次，并且只处理和存储了使用到的维度。这些优化保证了内存不会随着 dataset 维度和系列的增长而爆炸，大幅度的提升了这个极端场景下的初始化性能。刚才例子的渲染耗时也从假死降低到了可接受的`300ms`以下。

这次优化带来收益的还不只是这种高维的场景，在使用维度不高但是数据量很大的 dataset 的时候，因为数据的共享所以多个系列只处理了一遍数据，因此也可以带来显著的性能提升。

## 自定义系列的类型优化

自定义系列提供了非常灵活的创建系列图形的方式，相对于其它系列，自定义系列的上手成本会更高，而且容易出错，因此在这个版本中，我们进一步的优化了自定义系列中的核心方法`renderItem`的类型，对于`renderItem`的参数和返回值类型做了更精确的推断，从而可以根据返回的图形类型推断出可以设置该图形的哪些属性：

```ts
series = {
  type: 'custom',
  renderItem(params) {
    return {
      type: 'group',
      // group 类型使用 children 存储其它类型的子元素
      children: [
        {
          type: 'circle',
          // circle 拥有下面这些可以配置的 shape 属性
          shape: { r: 10, cx: 0, cy: 0 },
          // 可以配置的样式
          style: { fill: 'red' }
        },
        {
          type: 'rect',
          // rect 拥有下面这些可以配置的 shape 属性
          shape: { x: 0, y: 0, width: 100, height: 100 }
        },
        {
          type: 'path',
          // 自定义路径图形
          shape: { d: '...' }
        }
      ]
    };
  }
};
```
